
    ForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大人物分割成小任务，
最后将小任务聚合起来得到结果。它非常类似于HADOOP提供的MapReduce框架，只是MapReduce
的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin更加类
似于单机版的MapReduce。即使不通过mapreduce，仅有应用程序本身进行任务的分解与合成也是
可以的，但从实现难度上考虑，自己实现可能会带来较大规模的复杂度，因此程序员急需一种范式来
处理这一类的任务。在处理多线程中已经有了如AKKA这样的基于ACTOR模型的框架，而FORKJOIN则
是针对具有明显可以进行任务分割特性需求的实现。
   其应用场景为：如果一个应用程序能够被分解成多个子任务，而且结合多个子任务的结果就能够
得到最终的答案，那么它就适合使用FORK/JOIN模式来实现。

<1>Fork/Join使用两个类完成以上两件事情：

    · ForkJoinTask: 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在
      任务中执行fork()和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接
      继承其子类。
        RecursiveAction，用于没有返回结果的任务
        RecursiveTask，用于有返回值的任务

    · ForkJoinPool：task要通过ForkJoinPool来执行，分割的子任务也会添加到当前工作线程
      的双端队列中，进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部
      获取一个任务。

<2>ForkJoin框架使用了工作窃取的思想（work-stealing），工作窃取(work-stealing)算法是
指某个线程从其他队列里窃取任务来执行。
    假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线
 程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里
 的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任
 务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，
 于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取
 任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿
 任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。

    工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下
 还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个
 双端队列。