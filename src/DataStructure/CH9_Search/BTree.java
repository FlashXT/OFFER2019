package DataStructure.CH9_Search;

import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.ArrayBlockingQueue;

/************************************************************************************
 *                                         B树
 *1.定义：
 * B树：一种平衡得多路查找树，在文件系统中很有用：
 *
 * 一棵m阶的B树，或为空树，或为满足下列性质的m叉树：
 *   ①树中每个结点至多有m棵子树；
 *   ②若根结点不是叶子结点，则至少有2棵子树；
 *   ③除根之外的所有非终端结点至少有ceil(m/2)棵子树；
 *   ④所有的非终端结点中包含下列信息数据：
 *      （n,A0,K1,A1,K2,A2,...,Kn,An）
 *       其中，Ki(i=1,...,n)为关键字,且Ki< K(i+1)(i=1,...,n-1);Ai(i=0,...,n)为指向
 *    子树根结点的指针，且指针A(i-1)所指子树中所有结点的关键字均小于Ki(i=1,...,n),An所指
 *    子树中所有结点的关键字均大于Kn,n(ceil(m/2)-1)<= n <= m-1)为关键字的个数（或n+1为
 *    子树个数）。
 *      结点结构：{   节点个数：n;
 *                  关键字数组： K[n+1],n个关键字按照递增顺序排列(K[0]不使用)
 *                  孩子指针数组：p[n+1], p0<=k1,Ki < pi <= Ki+1,Kn< pn;
 *               }
 *
 *   ⑤所有叶子结点都出现在同一层次上，并且不带信息(可以看作是外部结点或查找失败的结点，实际
 *    上这些结点不存在，指向这些结点的指针为空.)
 *
 *2.查找操作
 *    1）先让key与根结点中的关键字比较，如果key等于k[i]（k[]为结点内的关键字数组），则查找成功
 *    2）若key< k[1]，则到p[0]所指示的子树中进行继续查找（p[]为结点内的指针数组），这里要注意
 *       B树中每个结点的内部结构。
 *    3）若key>k[n]，则道p[n]所指示的子树中继续查找。
 *    4）若k[i]< key< k[i+1]，则沿着指针p[i]所指示的子树继续查找。
 *    5）如果最后遇到空指针，则证明查找不成功。
 *
 *3.插入
 *       要确定一下每个结点中关键字个数的范围，如果B-树的阶数为m，则结点中关键字个数的范围为
 *    ceil(m/2)-1 ~ m-1个。
 *       对于关键字的插入，需要找到插入位置。在B树的查找过程中，当遇到空指针时，则证明查找不成
 *   功,同时也找到了插入位置，即根据空指针可以确定在最底层非叶结点中的插入位置,为了方便，我们称
 *   最底层的非叶结点为终端结点，由此可见，B树结点的插入总是落在终端结点上。
 *       在插入过程中,现在某个终端结点中添加一个关键字，如新关键字的插入破坏B树的特征(使得结点
 *   中关键字的个数超过规定个数m-1个)，则要进行结点的分裂：
 *
 *       按中间结点拆分,将结点中K[ceil(m/2)]放到父节点，如果父节点也不满足要求，
 *       就一直到向上分裂，直到所有结点满足要求；
 *4.删除
 *      对于B树关键字的删除，需要找到待删除的关键字，在结点中删除关键字的过程也有可能破坏B树
 *   的特性(使得结点中关键字的个数少于规定个数ceil(m/2)-1个)，这是可能需要向其兄弟结点借关
 *   键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并。
 ***********************************************************************************/
public class BTree {
    public static void main(String [] args){
        Scanner scan = new Scanner(System.in);
        int a = scan.nextInt();
        int b = scan.nextInt();
        scan.nextLine();
        String[] s = scan.nextLine().split(" ");
        System.out.println(Arrays.toString(s));

    }
}
